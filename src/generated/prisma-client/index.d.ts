// Code generated by Prisma (prisma@1.30.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  advancedSession: (where?: AdvancedSessionWhereInput) => Promise<boolean>;
  bout: (where?: BoutWhereInput) => Promise<boolean>;
  intensity: (where?: IntensityWhereInput) => Promise<boolean>;
  pause: (where?: PauseWhereInput) => Promise<boolean>;
  phase: (where?: PhaseWhereInput) => Promise<boolean>;
  plan: (where?: PlanWhereInput) => Promise<boolean>;
  session: (where?: SessionWhereInput) => Promise<boolean>;
  set: (where?: SetWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  week: (where?: WeekWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  advancedSession: (
    where: AdvancedSessionWhereUniqueInput
  ) => AdvancedSessionPromise;
  advancedSessions: (
    args?: {
      where?: AdvancedSessionWhereInput;
      orderBy?: AdvancedSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AdvancedSession>;
  advancedSessionsConnection: (
    args?: {
      where?: AdvancedSessionWhereInput;
      orderBy?: AdvancedSessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AdvancedSessionConnectionPromise;
  bouts: (
    args?: {
      where?: BoutWhereInput;
      orderBy?: BoutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Bout>;
  boutsConnection: (
    args?: {
      where?: BoutWhereInput;
      orderBy?: BoutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BoutConnectionPromise;
  intensity: (where: IntensityWhereUniqueInput) => IntensityPromise;
  intensities: (
    args?: {
      where?: IntensityWhereInput;
      orderBy?: IntensityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Intensity>;
  intensitiesConnection: (
    args?: {
      where?: IntensityWhereInput;
      orderBy?: IntensityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => IntensityConnectionPromise;
  pause: (where: PauseWhereUniqueInput) => PausePromise;
  pauses: (
    args?: {
      where?: PauseWhereInput;
      orderBy?: PauseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Pause>;
  pausesConnection: (
    args?: {
      where?: PauseWhereInput;
      orderBy?: PauseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PauseConnectionPromise;
  phase: (where: PhaseWhereUniqueInput) => PhasePromise;
  phases: (
    args?: {
      where?: PhaseWhereInput;
      orderBy?: PhaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Phase>;
  phasesConnection: (
    args?: {
      where?: PhaseWhereInput;
      orderBy?: PhaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PhaseConnectionPromise;
  plan: (where: PlanWhereUniqueInput) => PlanPromise;
  plans: (
    args?: {
      where?: PlanWhereInput;
      orderBy?: PlanOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Plan>;
  plansConnection: (
    args?: {
      where?: PlanWhereInput;
      orderBy?: PlanOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PlanConnectionPromise;
  session: (where: SessionWhereUniqueInput) => SessionPromise;
  sessions: (
    args?: {
      where?: SessionWhereInput;
      orderBy?: SessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Session>;
  sessionsConnection: (
    args?: {
      where?: SessionWhereInput;
      orderBy?: SessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SessionConnectionPromise;
  set: (where: SetWhereUniqueInput) => SetPromise;
  sets: (
    args?: {
      where?: SetWhereInput;
      orderBy?: SetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Set>;
  setsConnection: (
    args?: {
      where?: SetWhereInput;
      orderBy?: SetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SetConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  week: (where: WeekWhereUniqueInput) => WeekPromise;
  weeks: (
    args?: {
      where?: WeekWhereInput;
      orderBy?: WeekOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Week>;
  weeksConnection: (
    args?: {
      where?: WeekWhereInput;
      orderBy?: WeekOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WeekConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAdvancedSession: (
    data: AdvancedSessionCreateInput
  ) => AdvancedSessionPromise;
  updateAdvancedSession: (
    args: {
      data: AdvancedSessionUpdateInput;
      where: AdvancedSessionWhereUniqueInput;
    }
  ) => AdvancedSessionPromise;
  updateManyAdvancedSessions: (
    args: {
      data: AdvancedSessionUpdateManyMutationInput;
      where?: AdvancedSessionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAdvancedSession: (
    args: {
      where: AdvancedSessionWhereUniqueInput;
      create: AdvancedSessionCreateInput;
      update: AdvancedSessionUpdateInput;
    }
  ) => AdvancedSessionPromise;
  deleteAdvancedSession: (
    where: AdvancedSessionWhereUniqueInput
  ) => AdvancedSessionPromise;
  deleteManyAdvancedSessions: (
    where?: AdvancedSessionWhereInput
  ) => BatchPayloadPromise;
  createBout: (data: BoutCreateInput) => BoutPromise;
  updateManyBouts: (
    args: { data: BoutUpdateManyMutationInput; where?: BoutWhereInput }
  ) => BatchPayloadPromise;
  deleteManyBouts: (where?: BoutWhereInput) => BatchPayloadPromise;
  createIntensity: (data: IntensityCreateInput) => IntensityPromise;
  updateIntensity: (
    args: { data: IntensityUpdateInput; where: IntensityWhereUniqueInput }
  ) => IntensityPromise;
  updateManyIntensities: (
    args: {
      data: IntensityUpdateManyMutationInput;
      where?: IntensityWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertIntensity: (
    args: {
      where: IntensityWhereUniqueInput;
      create: IntensityCreateInput;
      update: IntensityUpdateInput;
    }
  ) => IntensityPromise;
  deleteIntensity: (where: IntensityWhereUniqueInput) => IntensityPromise;
  deleteManyIntensities: (where?: IntensityWhereInput) => BatchPayloadPromise;
  createPause: (data: PauseCreateInput) => PausePromise;
  updatePause: (
    args: { data: PauseUpdateInput; where: PauseWhereUniqueInput }
  ) => PausePromise;
  updateManyPauses: (
    args: { data: PauseUpdateManyMutationInput; where?: PauseWhereInput }
  ) => BatchPayloadPromise;
  upsertPause: (
    args: {
      where: PauseWhereUniqueInput;
      create: PauseCreateInput;
      update: PauseUpdateInput;
    }
  ) => PausePromise;
  deletePause: (where: PauseWhereUniqueInput) => PausePromise;
  deleteManyPauses: (where?: PauseWhereInput) => BatchPayloadPromise;
  createPhase: (data: PhaseCreateInput) => PhasePromise;
  updatePhase: (
    args: { data: PhaseUpdateInput; where: PhaseWhereUniqueInput }
  ) => PhasePromise;
  updateManyPhases: (
    args: { data: PhaseUpdateManyMutationInput; where?: PhaseWhereInput }
  ) => BatchPayloadPromise;
  upsertPhase: (
    args: {
      where: PhaseWhereUniqueInput;
      create: PhaseCreateInput;
      update: PhaseUpdateInput;
    }
  ) => PhasePromise;
  deletePhase: (where: PhaseWhereUniqueInput) => PhasePromise;
  deleteManyPhases: (where?: PhaseWhereInput) => BatchPayloadPromise;
  createPlan: (data: PlanCreateInput) => PlanPromise;
  updatePlan: (
    args: { data: PlanUpdateInput; where: PlanWhereUniqueInput }
  ) => PlanPromise;
  updateManyPlans: (
    args: { data: PlanUpdateManyMutationInput; where?: PlanWhereInput }
  ) => BatchPayloadPromise;
  upsertPlan: (
    args: {
      where: PlanWhereUniqueInput;
      create: PlanCreateInput;
      update: PlanUpdateInput;
    }
  ) => PlanPromise;
  deletePlan: (where: PlanWhereUniqueInput) => PlanPromise;
  deleteManyPlans: (where?: PlanWhereInput) => BatchPayloadPromise;
  createSession: (data: SessionCreateInput) => SessionPromise;
  updateSession: (
    args: { data: SessionUpdateInput; where: SessionWhereUniqueInput }
  ) => SessionPromise;
  updateManySessions: (
    args: { data: SessionUpdateManyMutationInput; where?: SessionWhereInput }
  ) => BatchPayloadPromise;
  upsertSession: (
    args: {
      where: SessionWhereUniqueInput;
      create: SessionCreateInput;
      update: SessionUpdateInput;
    }
  ) => SessionPromise;
  deleteSession: (where: SessionWhereUniqueInput) => SessionPromise;
  deleteManySessions: (where?: SessionWhereInput) => BatchPayloadPromise;
  createSet: (data: SetCreateInput) => SetPromise;
  updateSet: (
    args: { data: SetUpdateInput; where: SetWhereUniqueInput }
  ) => SetPromise;
  updateManySets: (
    args: { data: SetUpdateManyMutationInput; where?: SetWhereInput }
  ) => BatchPayloadPromise;
  upsertSet: (
    args: {
      where: SetWhereUniqueInput;
      create: SetCreateInput;
      update: SetUpdateInput;
    }
  ) => SetPromise;
  deleteSet: (where: SetWhereUniqueInput) => SetPromise;
  deleteManySets: (where?: SetWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createWeek: (data: WeekCreateInput) => WeekPromise;
  updateWeek: (
    args: { data: WeekUpdateInput; where: WeekWhereUniqueInput }
  ) => WeekPromise;
  updateManyWeeks: (
    args: { data: WeekUpdateManyMutationInput; where?: WeekWhereInput }
  ) => BatchPayloadPromise;
  upsertWeek: (
    args: {
      where: WeekWhereUniqueInput;
      create: WeekCreateInput;
      update: WeekUpdateInput;
    }
  ) => WeekPromise;
  deleteWeek: (where: WeekWhereUniqueInput) => WeekPromise;
  deleteManyWeeks: (where?: WeekWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  advancedSession: (
    where?: AdvancedSessionSubscriptionWhereInput
  ) => AdvancedSessionSubscriptionPayloadSubscription;
  bout: (
    where?: BoutSubscriptionWhereInput
  ) => BoutSubscriptionPayloadSubscription;
  intensity: (
    where?: IntensitySubscriptionWhereInput
  ) => IntensitySubscriptionPayloadSubscription;
  pause: (
    where?: PauseSubscriptionWhereInput
  ) => PauseSubscriptionPayloadSubscription;
  phase: (
    where?: PhaseSubscriptionWhereInput
  ) => PhaseSubscriptionPayloadSubscription;
  plan: (
    where?: PlanSubscriptionWhereInput
  ) => PlanSubscriptionPayloadSubscription;
  session: (
    where?: SessionSubscriptionWhereInput
  ) => SessionSubscriptionPayloadSubscription;
  set: (
    where?: SetSubscriptionWhereInput
  ) => SetSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  week: (
    where?: WeekSubscriptionWhereInput
  ) => WeekSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PlanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PhaseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WeekOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "purpose_ASC"
  | "purpose_DESC"
  | "day_ASC"
  | "day_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type IntensityType =
  | "Interval"
  | "Hard"
  | "Repetition"
  | "Easy"
  | "Long"
  | "Threshold"
  | "MarathonPace";

export type PauseType = "Rest" | "Active";

export type SetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "order_ASC"
  | "order_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BoutOrderByInput =
  | "duration_ASC"
  | "duration_DESC"
  | "length_ASC"
  | "length_DESC"
  | "order_ASC"
  | "order_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PauseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "length_ASC"
  | "length_DESC"
  | "order_ASC"
  | "order_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AdvancedSessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "purpose_ASC"
  | "purpose_DESC"
  | "day_ASC"
  | "day_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type IntensityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "type_ASC"
  | "type_DESC"
  | "coefficient_ASC"
  | "coefficient_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AdvancedSessionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PlanWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdBy?: UserWhereInput;
  phases_every?: PhaseWhereInput;
  phases_some?: PhaseWhereInput;
  phases_none?: PhaseWhereInput;
  AND?: PlanWhereInput[] | PlanWhereInput;
  OR?: PlanWhereInput[] | PlanWhereInput;
  NOT?: PlanWhereInput[] | PlanWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  plans_every?: PlanWhereInput;
  plans_some?: PlanWhereInput;
  plans_none?: PlanWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface PhaseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdBy?: UserWhereInput;
  weeks_every?: WeekWhereInput;
  weeks_some?: WeekWhereInput;
  weeks_none?: WeekWhereInput;
  plan?: PlanWhereInput;
  AND?: PhaseWhereInput[] | PhaseWhereInput;
  OR?: PhaseWhereInput[] | PhaseWhereInput;
  NOT?: PhaseWhereInput[] | PhaseWhereInput;
}

export interface WeekWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  createdBy?: UserWhereInput;
  sessions_every?: SessionWhereInput;
  sessions_some?: SessionWhereInput;
  sessions_none?: SessionWhereInput;
  phase?: PhaseWhereInput;
  AND?: WeekWhereInput[] | WeekWhereInput;
  OR?: WeekWhereInput[] | WeekWhereInput;
  NOT?: WeekWhereInput[] | WeekWhereInput;
}

export interface SessionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  purpose?: String;
  purpose_not?: String;
  purpose_in?: String[] | String;
  purpose_not_in?: String[] | String;
  purpose_lt?: String;
  purpose_lte?: String;
  purpose_gt?: String;
  purpose_gte?: String;
  purpose_contains?: String;
  purpose_not_contains?: String;
  purpose_starts_with?: String;
  purpose_not_starts_with?: String;
  purpose_ends_with?: String;
  purpose_not_ends_with?: String;
  day?: Int;
  day_not?: Int;
  day_in?: Int[] | Int;
  day_not_in?: Int[] | Int;
  day_lt?: Int;
  day_lte?: Int;
  day_gt?: Int;
  day_gte?: Int;
  createdBy?: UserWhereInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: SessionWhereInput[] | SessionWhereInput;
  OR?: SessionWhereInput[] | SessionWhereInput;
  NOT?: SessionWhereInput[] | SessionWhereInput;
}

export interface SetWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  bouts_every?: BoutWhereInput;
  bouts_some?: BoutWhereInput;
  bouts_none?: BoutWhereInput;
  pauses_every?: PauseWhereInput;
  pauses_some?: PauseWhereInput;
  pauses_none?: PauseWhereInput;
  session?: SessionWhereInput;
  AND?: SetWhereInput[] | SetWhereInput;
  OR?: SetWhereInput[] | SetWhereInput;
  NOT?: SetWhereInput[] | SetWhereInput;
}

export interface BoutWhereInput {
  intensity?: IntensityWhereInput;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  length?: Int;
  length_not?: Int;
  length_in?: Int[] | Int;
  length_not_in?: Int[] | Int;
  length_lt?: Int;
  length_lte?: Int;
  length_gt?: Int;
  length_gte?: Int;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  set?: SetWhereInput;
  AND?: BoutWhereInput[] | BoutWhereInput;
  OR?: BoutWhereInput[] | BoutWhereInput;
  NOT?: BoutWhereInput[] | BoutWhereInput;
}

export interface IntensityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  type?: IntensityType;
  type_not?: IntensityType;
  type_in?: IntensityType[] | IntensityType;
  type_not_in?: IntensityType[] | IntensityType;
  coefficient?: Float;
  coefficient_not?: Float;
  coefficient_in?: Float[] | Float;
  coefficient_not_in?: Float[] | Float;
  coefficient_lt?: Float;
  coefficient_lte?: Float;
  coefficient_gt?: Float;
  coefficient_gte?: Float;
  AND?: IntensityWhereInput[] | IntensityWhereInput;
  OR?: IntensityWhereInput[] | IntensityWhereInput;
  NOT?: IntensityWhereInput[] | IntensityWhereInput;
}

export interface PauseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  length?: Int;
  length_not?: Int;
  length_in?: Int[] | Int;
  length_not_in?: Int[] | Int;
  length_lt?: Int;
  length_lte?: Int;
  length_gt?: Int;
  length_gte?: Int;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  type?: PauseType;
  type_not?: PauseType;
  type_in?: PauseType[] | PauseType;
  type_not_in?: PauseType[] | PauseType;
  set?: SetWhereInput;
  session?: SessionWhereInput;
  AND?: PauseWhereInput[] | PauseWhereInput;
  OR?: PauseWhereInput[] | PauseWhereInput;
  NOT?: PauseWhereInput[] | PauseWhereInput;
}

export interface AdvancedSessionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  purpose?: String;
  purpose_not?: String;
  purpose_in?: String[] | String;
  purpose_not_in?: String[] | String;
  purpose_lt?: String;
  purpose_lte?: String;
  purpose_gt?: String;
  purpose_gte?: String;
  purpose_contains?: String;
  purpose_not_contains?: String;
  purpose_starts_with?: String;
  purpose_not_starts_with?: String;
  purpose_ends_with?: String;
  purpose_not_ends_with?: String;
  day?: Int;
  day_not?: Int;
  day_in?: Int[] | Int;
  day_not_in?: Int[] | Int;
  day_lt?: Int;
  day_lte?: Int;
  day_gt?: Int;
  day_gte?: Int;
  createdBy?: UserWhereInput;
  week_every?: WeekWhereInput;
  week_some?: WeekWhereInput;
  week_none?: WeekWhereInput;
  sets_every?: SetWhereInput;
  sets_some?: SetWhereInput;
  sets_none?: SetWhereInput;
  pauses_every?: PauseWhereInput;
  pauses_some?: PauseWhereInput;
  pauses_none?: PauseWhereInput;
  AND?: AdvancedSessionWhereInput[] | AdvancedSessionWhereInput;
  OR?: AdvancedSessionWhereInput[] | AdvancedSessionWhereInput;
  NOT?: AdvancedSessionWhereInput[] | AdvancedSessionWhereInput;
}

export type IntensityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PauseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PhaseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PlanWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SessionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SetWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export type WeekWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AdvancedSessionCreateInput {
  title?: String;
  purpose?: String;
  day?: Int;
  createdBy: UserCreateOneInput;
  week?: WeekCreateManyInput;
  sets?: SetCreateManyInput;
  pauses?: PauseCreateManyInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  name: String;
  email: String;
  password: String;
  plans?: PlanCreateManyWithoutCreatedByInput;
}

export interface PlanCreateManyWithoutCreatedByInput {
  create?: PlanCreateWithoutCreatedByInput[] | PlanCreateWithoutCreatedByInput;
  connect?: PlanWhereUniqueInput[] | PlanWhereUniqueInput;
}

export interface PlanCreateWithoutCreatedByInput {
  title: String;
  description?: String;
  phases?: PhaseCreateManyWithoutPlanInput;
}

export interface PhaseCreateManyWithoutPlanInput {
  create?: PhaseCreateWithoutPlanInput[] | PhaseCreateWithoutPlanInput;
  connect?: PhaseWhereUniqueInput[] | PhaseWhereUniqueInput;
}

export interface PhaseCreateWithoutPlanInput {
  title: String;
  description?: String;
  order?: Int;
  createdBy: UserCreateOneInput;
  weeks?: WeekCreateManyWithoutPhaseInput;
}

export interface WeekCreateManyWithoutPhaseInput {
  create?: WeekCreateWithoutPhaseInput[] | WeekCreateWithoutPhaseInput;
  connect?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
}

export interface WeekCreateWithoutPhaseInput {
  description?: String;
  order?: Int;
  createdBy: UserCreateOneInput;
  sessions?: SessionCreateManyInput;
}

export interface SessionCreateManyInput {
  create?: SessionCreateInput[] | SessionCreateInput;
  connect?: SessionWhereUniqueInput[] | SessionWhereUniqueInput;
}

export interface SessionCreateInput {
  title?: String;
  purpose?: String;
  day?: Int;
  createdBy: UserCreateOneInput;
  description?: String;
}

export interface WeekCreateManyInput {
  create?: WeekCreateInput[] | WeekCreateInput;
  connect?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
}

export interface WeekCreateInput {
  description?: String;
  order?: Int;
  createdBy: UserCreateOneInput;
  sessions?: SessionCreateManyInput;
  phase?: PhaseCreateOneWithoutWeeksInput;
}

export interface PhaseCreateOneWithoutWeeksInput {
  create?: PhaseCreateWithoutWeeksInput;
  connect?: PhaseWhereUniqueInput;
}

export interface PhaseCreateWithoutWeeksInput {
  title: String;
  description?: String;
  order?: Int;
  createdBy: UserCreateOneInput;
  plan: PlanCreateOneWithoutPhasesInput;
}

export interface PlanCreateOneWithoutPhasesInput {
  create?: PlanCreateWithoutPhasesInput;
  connect?: PlanWhereUniqueInput;
}

export interface PlanCreateWithoutPhasesInput {
  title: String;
  description?: String;
  createdBy: UserCreateOneWithoutPlansInput;
}

export interface UserCreateOneWithoutPlansInput {
  create?: UserCreateWithoutPlansInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutPlansInput {
  name: String;
  email: String;
  password: String;
}

export interface SetCreateManyInput {
  create?: SetCreateInput[] | SetCreateInput;
  connect?: SetWhereUniqueInput[] | SetWhereUniqueInput;
}

export interface SetCreateInput {
  title: String;
  order: Int;
  bouts?: BoutCreateManyWithoutSetInput;
  pauses?: PauseCreateManyWithoutSetInput;
  session?: SessionCreateOneInput;
}

export interface BoutCreateManyWithoutSetInput {
  create?: BoutCreateWithoutSetInput[] | BoutCreateWithoutSetInput;
}

export interface BoutCreateWithoutSetInput {
  intensity?: IntensityCreateOneInput;
  duration?: Int;
  length?: Int;
  order: Int;
}

export interface IntensityCreateOneInput {
  create?: IntensityCreateInput;
  connect?: IntensityWhereUniqueInput;
}

export interface IntensityCreateInput {
  title: String;
  description?: String;
  type?: IntensityType;
  coefficient: Float;
}

export interface PauseCreateManyWithoutSetInput {
  create?: PauseCreateWithoutSetInput[] | PauseCreateWithoutSetInput;
  connect?: PauseWhereUniqueInput[] | PauseWhereUniqueInput;
}

export interface PauseCreateWithoutSetInput {
  duration?: Int;
  length?: Int;
  order: Int;
  type?: PauseType;
  session?: SessionCreateOneInput;
}

export interface SessionCreateOneInput {
  create?: SessionCreateInput;
  connect?: SessionWhereUniqueInput;
}

export interface PauseCreateManyInput {
  create?: PauseCreateInput[] | PauseCreateInput;
  connect?: PauseWhereUniqueInput[] | PauseWhereUniqueInput;
}

export interface PauseCreateInput {
  duration?: Int;
  length?: Int;
  order: Int;
  type?: PauseType;
  set?: SetCreateOneWithoutPausesInput;
  session?: SessionCreateOneInput;
}

export interface SetCreateOneWithoutPausesInput {
  create?: SetCreateWithoutPausesInput;
  connect?: SetWhereUniqueInput;
}

export interface SetCreateWithoutPausesInput {
  title: String;
  order: Int;
  bouts?: BoutCreateManyWithoutSetInput;
  session?: SessionCreateOneInput;
}

export interface AdvancedSessionUpdateInput {
  title?: String;
  purpose?: String;
  day?: Int;
  createdBy?: UserUpdateOneRequiredInput;
  week?: WeekUpdateManyInput;
  sets?: SetUpdateManyInput;
  pauses?: PauseUpdateManyInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateDataInput {
  name?: String;
  email?: String;
  password?: String;
  plans?: PlanUpdateManyWithoutCreatedByInput;
}

export interface PlanUpdateManyWithoutCreatedByInput {
  create?: PlanCreateWithoutCreatedByInput[] | PlanCreateWithoutCreatedByInput;
  delete?: PlanWhereUniqueInput[] | PlanWhereUniqueInput;
  connect?: PlanWhereUniqueInput[] | PlanWhereUniqueInput;
  set?: PlanWhereUniqueInput[] | PlanWhereUniqueInput;
  disconnect?: PlanWhereUniqueInput[] | PlanWhereUniqueInput;
  update?:
    | PlanUpdateWithWhereUniqueWithoutCreatedByInput[]
    | PlanUpdateWithWhereUniqueWithoutCreatedByInput;
  upsert?:
    | PlanUpsertWithWhereUniqueWithoutCreatedByInput[]
    | PlanUpsertWithWhereUniqueWithoutCreatedByInput;
  deleteMany?: PlanScalarWhereInput[] | PlanScalarWhereInput;
  updateMany?:
    | PlanUpdateManyWithWhereNestedInput[]
    | PlanUpdateManyWithWhereNestedInput;
}

export interface PlanUpdateWithWhereUniqueWithoutCreatedByInput {
  where: PlanWhereUniqueInput;
  data: PlanUpdateWithoutCreatedByDataInput;
}

export interface PlanUpdateWithoutCreatedByDataInput {
  title?: String;
  description?: String;
  phases?: PhaseUpdateManyWithoutPlanInput;
}

export interface PhaseUpdateManyWithoutPlanInput {
  create?: PhaseCreateWithoutPlanInput[] | PhaseCreateWithoutPlanInput;
  delete?: PhaseWhereUniqueInput[] | PhaseWhereUniqueInput;
  connect?: PhaseWhereUniqueInput[] | PhaseWhereUniqueInput;
  set?: PhaseWhereUniqueInput[] | PhaseWhereUniqueInput;
  disconnect?: PhaseWhereUniqueInput[] | PhaseWhereUniqueInput;
  update?:
    | PhaseUpdateWithWhereUniqueWithoutPlanInput[]
    | PhaseUpdateWithWhereUniqueWithoutPlanInput;
  upsert?:
    | PhaseUpsertWithWhereUniqueWithoutPlanInput[]
    | PhaseUpsertWithWhereUniqueWithoutPlanInput;
  deleteMany?: PhaseScalarWhereInput[] | PhaseScalarWhereInput;
  updateMany?:
    | PhaseUpdateManyWithWhereNestedInput[]
    | PhaseUpdateManyWithWhereNestedInput;
}

export interface PhaseUpdateWithWhereUniqueWithoutPlanInput {
  where: PhaseWhereUniqueInput;
  data: PhaseUpdateWithoutPlanDataInput;
}

export interface PhaseUpdateWithoutPlanDataInput {
  title?: String;
  description?: String;
  order?: Int;
  createdBy?: UserUpdateOneRequiredInput;
  weeks?: WeekUpdateManyWithoutPhaseInput;
}

export interface WeekUpdateManyWithoutPhaseInput {
  create?: WeekCreateWithoutPhaseInput[] | WeekCreateWithoutPhaseInput;
  delete?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
  connect?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
  set?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
  disconnect?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
  update?:
    | WeekUpdateWithWhereUniqueWithoutPhaseInput[]
    | WeekUpdateWithWhereUniqueWithoutPhaseInput;
  upsert?:
    | WeekUpsertWithWhereUniqueWithoutPhaseInput[]
    | WeekUpsertWithWhereUniqueWithoutPhaseInput;
  deleteMany?: WeekScalarWhereInput[] | WeekScalarWhereInput;
  updateMany?:
    | WeekUpdateManyWithWhereNestedInput[]
    | WeekUpdateManyWithWhereNestedInput;
}

export interface WeekUpdateWithWhereUniqueWithoutPhaseInput {
  where: WeekWhereUniqueInput;
  data: WeekUpdateWithoutPhaseDataInput;
}

export interface WeekUpdateWithoutPhaseDataInput {
  description?: String;
  order?: Int;
  createdBy?: UserUpdateOneRequiredInput;
  sessions?: SessionUpdateManyInput;
}

export interface SessionUpdateManyInput {
  create?: SessionCreateInput[] | SessionCreateInput;
  update?:
    | SessionUpdateWithWhereUniqueNestedInput[]
    | SessionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SessionUpsertWithWhereUniqueNestedInput[]
    | SessionUpsertWithWhereUniqueNestedInput;
  delete?: SessionWhereUniqueInput[] | SessionWhereUniqueInput;
  connect?: SessionWhereUniqueInput[] | SessionWhereUniqueInput;
  set?: SessionWhereUniqueInput[] | SessionWhereUniqueInput;
  disconnect?: SessionWhereUniqueInput[] | SessionWhereUniqueInput;
  deleteMany?: SessionScalarWhereInput[] | SessionScalarWhereInput;
  updateMany?:
    | SessionUpdateManyWithWhereNestedInput[]
    | SessionUpdateManyWithWhereNestedInput;
}

export interface SessionUpdateWithWhereUniqueNestedInput {
  where: SessionWhereUniqueInput;
  data: SessionUpdateDataInput;
}

export interface SessionUpdateDataInput {
  title?: String;
  purpose?: String;
  day?: Int;
  createdBy?: UserUpdateOneRequiredInput;
  description?: String;
}

export interface SessionUpsertWithWhereUniqueNestedInput {
  where: SessionWhereUniqueInput;
  update: SessionUpdateDataInput;
  create: SessionCreateInput;
}

export interface SessionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  purpose?: String;
  purpose_not?: String;
  purpose_in?: String[] | String;
  purpose_not_in?: String[] | String;
  purpose_lt?: String;
  purpose_lte?: String;
  purpose_gt?: String;
  purpose_gte?: String;
  purpose_contains?: String;
  purpose_not_contains?: String;
  purpose_starts_with?: String;
  purpose_not_starts_with?: String;
  purpose_ends_with?: String;
  purpose_not_ends_with?: String;
  day?: Int;
  day_not?: Int;
  day_in?: Int[] | Int;
  day_not_in?: Int[] | Int;
  day_lt?: Int;
  day_lte?: Int;
  day_gt?: Int;
  day_gte?: Int;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: SessionScalarWhereInput[] | SessionScalarWhereInput;
  OR?: SessionScalarWhereInput[] | SessionScalarWhereInput;
  NOT?: SessionScalarWhereInput[] | SessionScalarWhereInput;
}

export interface SessionUpdateManyWithWhereNestedInput {
  where: SessionScalarWhereInput;
  data: SessionUpdateManyDataInput;
}

export interface SessionUpdateManyDataInput {
  title?: String;
  purpose?: String;
  day?: Int;
  description?: String;
}

export interface WeekUpsertWithWhereUniqueWithoutPhaseInput {
  where: WeekWhereUniqueInput;
  update: WeekUpdateWithoutPhaseDataInput;
  create: WeekCreateWithoutPhaseInput;
}

export interface WeekScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  AND?: WeekScalarWhereInput[] | WeekScalarWhereInput;
  OR?: WeekScalarWhereInput[] | WeekScalarWhereInput;
  NOT?: WeekScalarWhereInput[] | WeekScalarWhereInput;
}

export interface WeekUpdateManyWithWhereNestedInput {
  where: WeekScalarWhereInput;
  data: WeekUpdateManyDataInput;
}

export interface WeekUpdateManyDataInput {
  description?: String;
  order?: Int;
}

export interface PhaseUpsertWithWhereUniqueWithoutPlanInput {
  where: PhaseWhereUniqueInput;
  update: PhaseUpdateWithoutPlanDataInput;
  create: PhaseCreateWithoutPlanInput;
}

export interface PhaseScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  AND?: PhaseScalarWhereInput[] | PhaseScalarWhereInput;
  OR?: PhaseScalarWhereInput[] | PhaseScalarWhereInput;
  NOT?: PhaseScalarWhereInput[] | PhaseScalarWhereInput;
}

export interface PhaseUpdateManyWithWhereNestedInput {
  where: PhaseScalarWhereInput;
  data: PhaseUpdateManyDataInput;
}

export interface PhaseUpdateManyDataInput {
  title?: String;
  description?: String;
  order?: Int;
}

export interface PlanUpsertWithWhereUniqueWithoutCreatedByInput {
  where: PlanWhereUniqueInput;
  update: PlanUpdateWithoutCreatedByDataInput;
  create: PlanCreateWithoutCreatedByInput;
}

export interface PlanScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: PlanScalarWhereInput[] | PlanScalarWhereInput;
  OR?: PlanScalarWhereInput[] | PlanScalarWhereInput;
  NOT?: PlanScalarWhereInput[] | PlanScalarWhereInput;
}

export interface PlanUpdateManyWithWhereNestedInput {
  where: PlanScalarWhereInput;
  data: PlanUpdateManyDataInput;
}

export interface PlanUpdateManyDataInput {
  title?: String;
  description?: String;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface WeekUpdateManyInput {
  create?: WeekCreateInput[] | WeekCreateInput;
  update?:
    | WeekUpdateWithWhereUniqueNestedInput[]
    | WeekUpdateWithWhereUniqueNestedInput;
  upsert?:
    | WeekUpsertWithWhereUniqueNestedInput[]
    | WeekUpsertWithWhereUniqueNestedInput;
  delete?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
  connect?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
  set?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
  disconnect?: WeekWhereUniqueInput[] | WeekWhereUniqueInput;
  deleteMany?: WeekScalarWhereInput[] | WeekScalarWhereInput;
  updateMany?:
    | WeekUpdateManyWithWhereNestedInput[]
    | WeekUpdateManyWithWhereNestedInput;
}

export interface WeekUpdateWithWhereUniqueNestedInput {
  where: WeekWhereUniqueInput;
  data: WeekUpdateDataInput;
}

export interface WeekUpdateDataInput {
  description?: String;
  order?: Int;
  createdBy?: UserUpdateOneRequiredInput;
  sessions?: SessionUpdateManyInput;
  phase?: PhaseUpdateOneWithoutWeeksInput;
}

export interface PhaseUpdateOneWithoutWeeksInput {
  create?: PhaseCreateWithoutWeeksInput;
  update?: PhaseUpdateWithoutWeeksDataInput;
  upsert?: PhaseUpsertWithoutWeeksInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PhaseWhereUniqueInput;
}

export interface PhaseUpdateWithoutWeeksDataInput {
  title?: String;
  description?: String;
  order?: Int;
  createdBy?: UserUpdateOneRequiredInput;
  plan?: PlanUpdateOneRequiredWithoutPhasesInput;
}

export interface PlanUpdateOneRequiredWithoutPhasesInput {
  create?: PlanCreateWithoutPhasesInput;
  update?: PlanUpdateWithoutPhasesDataInput;
  upsert?: PlanUpsertWithoutPhasesInput;
  connect?: PlanWhereUniqueInput;
}

export interface PlanUpdateWithoutPhasesDataInput {
  title?: String;
  description?: String;
  createdBy?: UserUpdateOneRequiredWithoutPlansInput;
}

export interface UserUpdateOneRequiredWithoutPlansInput {
  create?: UserCreateWithoutPlansInput;
  update?: UserUpdateWithoutPlansDataInput;
  upsert?: UserUpsertWithoutPlansInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutPlansDataInput {
  name?: String;
  email?: String;
  password?: String;
}

export interface UserUpsertWithoutPlansInput {
  update: UserUpdateWithoutPlansDataInput;
  create: UserCreateWithoutPlansInput;
}

export interface PlanUpsertWithoutPhasesInput {
  update: PlanUpdateWithoutPhasesDataInput;
  create: PlanCreateWithoutPhasesInput;
}

export interface PhaseUpsertWithoutWeeksInput {
  update: PhaseUpdateWithoutWeeksDataInput;
  create: PhaseCreateWithoutWeeksInput;
}

export interface WeekUpsertWithWhereUniqueNestedInput {
  where: WeekWhereUniqueInput;
  update: WeekUpdateDataInput;
  create: WeekCreateInput;
}

export interface SetUpdateManyInput {
  create?: SetCreateInput[] | SetCreateInput;
  update?:
    | SetUpdateWithWhereUniqueNestedInput[]
    | SetUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SetUpsertWithWhereUniqueNestedInput[]
    | SetUpsertWithWhereUniqueNestedInput;
  delete?: SetWhereUniqueInput[] | SetWhereUniqueInput;
  connect?: SetWhereUniqueInput[] | SetWhereUniqueInput;
  set?: SetWhereUniqueInput[] | SetWhereUniqueInput;
  disconnect?: SetWhereUniqueInput[] | SetWhereUniqueInput;
  deleteMany?: SetScalarWhereInput[] | SetScalarWhereInput;
  updateMany?:
    | SetUpdateManyWithWhereNestedInput[]
    | SetUpdateManyWithWhereNestedInput;
}

export interface SetUpdateWithWhereUniqueNestedInput {
  where: SetWhereUniqueInput;
  data: SetUpdateDataInput;
}

export interface SetUpdateDataInput {
  title?: String;
  order?: Int;
  bouts?: BoutUpdateManyWithoutSetInput;
  pauses?: PauseUpdateManyWithoutSetInput;
  session?: SessionUpdateOneInput;
}

export interface BoutUpdateManyWithoutSetInput {
  create?: BoutCreateWithoutSetInput[] | BoutCreateWithoutSetInput;
  deleteMany?: BoutScalarWhereInput[] | BoutScalarWhereInput;
  updateMany?:
    | BoutUpdateManyWithWhereNestedInput[]
    | BoutUpdateManyWithWhereNestedInput;
}

export interface BoutScalarWhereInput {
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  length?: Int;
  length_not?: Int;
  length_in?: Int[] | Int;
  length_not_in?: Int[] | Int;
  length_lt?: Int;
  length_lte?: Int;
  length_gt?: Int;
  length_gte?: Int;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  AND?: BoutScalarWhereInput[] | BoutScalarWhereInput;
  OR?: BoutScalarWhereInput[] | BoutScalarWhereInput;
  NOT?: BoutScalarWhereInput[] | BoutScalarWhereInput;
}

export interface BoutUpdateManyWithWhereNestedInput {
  where: BoutScalarWhereInput;
  data: BoutUpdateManyDataInput;
}

export interface BoutUpdateManyDataInput {
  duration?: Int;
  length?: Int;
  order?: Int;
}

export interface PauseUpdateManyWithoutSetInput {
  create?: PauseCreateWithoutSetInput[] | PauseCreateWithoutSetInput;
  delete?: PauseWhereUniqueInput[] | PauseWhereUniqueInput;
  connect?: PauseWhereUniqueInput[] | PauseWhereUniqueInput;
  set?: PauseWhereUniqueInput[] | PauseWhereUniqueInput;
  disconnect?: PauseWhereUniqueInput[] | PauseWhereUniqueInput;
  update?:
    | PauseUpdateWithWhereUniqueWithoutSetInput[]
    | PauseUpdateWithWhereUniqueWithoutSetInput;
  upsert?:
    | PauseUpsertWithWhereUniqueWithoutSetInput[]
    | PauseUpsertWithWhereUniqueWithoutSetInput;
  deleteMany?: PauseScalarWhereInput[] | PauseScalarWhereInput;
  updateMany?:
    | PauseUpdateManyWithWhereNestedInput[]
    | PauseUpdateManyWithWhereNestedInput;
}

export interface PauseUpdateWithWhereUniqueWithoutSetInput {
  where: PauseWhereUniqueInput;
  data: PauseUpdateWithoutSetDataInput;
}

export interface PauseUpdateWithoutSetDataInput {
  duration?: Int;
  length?: Int;
  order?: Int;
  type?: PauseType;
  session?: SessionUpdateOneInput;
}

export interface SessionUpdateOneInput {
  create?: SessionCreateInput;
  update?: SessionUpdateDataInput;
  upsert?: SessionUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SessionWhereUniqueInput;
}

export interface SessionUpsertNestedInput {
  update: SessionUpdateDataInput;
  create: SessionCreateInput;
}

export interface PauseUpsertWithWhereUniqueWithoutSetInput {
  where: PauseWhereUniqueInput;
  update: PauseUpdateWithoutSetDataInput;
  create: PauseCreateWithoutSetInput;
}

export interface PauseScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  length?: Int;
  length_not?: Int;
  length_in?: Int[] | Int;
  length_not_in?: Int[] | Int;
  length_lt?: Int;
  length_lte?: Int;
  length_gt?: Int;
  length_gte?: Int;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  type?: PauseType;
  type_not?: PauseType;
  type_in?: PauseType[] | PauseType;
  type_not_in?: PauseType[] | PauseType;
  AND?: PauseScalarWhereInput[] | PauseScalarWhereInput;
  OR?: PauseScalarWhereInput[] | PauseScalarWhereInput;
  NOT?: PauseScalarWhereInput[] | PauseScalarWhereInput;
}

export interface PauseUpdateManyWithWhereNestedInput {
  where: PauseScalarWhereInput;
  data: PauseUpdateManyDataInput;
}

export interface PauseUpdateManyDataInput {
  duration?: Int;
  length?: Int;
  order?: Int;
  type?: PauseType;
}

export interface SetUpsertWithWhereUniqueNestedInput {
  where: SetWhereUniqueInput;
  update: SetUpdateDataInput;
  create: SetCreateInput;
}

export interface SetScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  order?: Int;
  order_not?: Int;
  order_in?: Int[] | Int;
  order_not_in?: Int[] | Int;
  order_lt?: Int;
  order_lte?: Int;
  order_gt?: Int;
  order_gte?: Int;
  AND?: SetScalarWhereInput[] | SetScalarWhereInput;
  OR?: SetScalarWhereInput[] | SetScalarWhereInput;
  NOT?: SetScalarWhereInput[] | SetScalarWhereInput;
}

export interface SetUpdateManyWithWhereNestedInput {
  where: SetScalarWhereInput;
  data: SetUpdateManyDataInput;
}

export interface SetUpdateManyDataInput {
  title?: String;
  order?: Int;
}

export interface PauseUpdateManyInput {
  create?: PauseCreateInput[] | PauseCreateInput;
  update?:
    | PauseUpdateWithWhereUniqueNestedInput[]
    | PauseUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PauseUpsertWithWhereUniqueNestedInput[]
    | PauseUpsertWithWhereUniqueNestedInput;
  delete?: PauseWhereUniqueInput[] | PauseWhereUniqueInput;
  connect?: PauseWhereUniqueInput[] | PauseWhereUniqueInput;
  set?: PauseWhereUniqueInput[] | PauseWhereUniqueInput;
  disconnect?: PauseWhereUniqueInput[] | PauseWhereUniqueInput;
  deleteMany?: PauseScalarWhereInput[] | PauseScalarWhereInput;
  updateMany?:
    | PauseUpdateManyWithWhereNestedInput[]
    | PauseUpdateManyWithWhereNestedInput;
}

export interface PauseUpdateWithWhereUniqueNestedInput {
  where: PauseWhereUniqueInput;
  data: PauseUpdateDataInput;
}

export interface PauseUpdateDataInput {
  duration?: Int;
  length?: Int;
  order?: Int;
  type?: PauseType;
  set?: SetUpdateOneWithoutPausesInput;
  session?: SessionUpdateOneInput;
}

export interface SetUpdateOneWithoutPausesInput {
  create?: SetCreateWithoutPausesInput;
  update?: SetUpdateWithoutPausesDataInput;
  upsert?: SetUpsertWithoutPausesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SetWhereUniqueInput;
}

export interface SetUpdateWithoutPausesDataInput {
  title?: String;
  order?: Int;
  bouts?: BoutUpdateManyWithoutSetInput;
  session?: SessionUpdateOneInput;
}

export interface SetUpsertWithoutPausesInput {
  update: SetUpdateWithoutPausesDataInput;
  create: SetCreateWithoutPausesInput;
}

export interface PauseUpsertWithWhereUniqueNestedInput {
  where: PauseWhereUniqueInput;
  update: PauseUpdateDataInput;
  create: PauseCreateInput;
}

export interface AdvancedSessionUpdateManyMutationInput {
  title?: String;
  purpose?: String;
  day?: Int;
}

export interface BoutCreateInput {
  intensity?: IntensityCreateOneInput;
  duration?: Int;
  length?: Int;
  order: Int;
  set: SetCreateOneWithoutBoutsInput;
}

export interface SetCreateOneWithoutBoutsInput {
  create?: SetCreateWithoutBoutsInput;
  connect?: SetWhereUniqueInput;
}

export interface SetCreateWithoutBoutsInput {
  title: String;
  order: Int;
  pauses?: PauseCreateManyWithoutSetInput;
  session?: SessionCreateOneInput;
}

export interface BoutUpdateManyMutationInput {
  duration?: Int;
  length?: Int;
  order?: Int;
}

export interface IntensityUpdateInput {
  title?: String;
  description?: String;
  type?: IntensityType;
  coefficient?: Float;
}

export interface IntensityUpdateManyMutationInput {
  title?: String;
  description?: String;
  type?: IntensityType;
  coefficient?: Float;
}

export interface PauseUpdateInput {
  duration?: Int;
  length?: Int;
  order?: Int;
  type?: PauseType;
  set?: SetUpdateOneWithoutPausesInput;
  session?: SessionUpdateOneInput;
}

export interface PauseUpdateManyMutationInput {
  duration?: Int;
  length?: Int;
  order?: Int;
  type?: PauseType;
}

export interface PhaseCreateInput {
  title: String;
  description?: String;
  order?: Int;
  createdBy: UserCreateOneInput;
  weeks?: WeekCreateManyWithoutPhaseInput;
  plan: PlanCreateOneWithoutPhasesInput;
}

export interface PhaseUpdateInput {
  title?: String;
  description?: String;
  order?: Int;
  createdBy?: UserUpdateOneRequiredInput;
  weeks?: WeekUpdateManyWithoutPhaseInput;
  plan?: PlanUpdateOneRequiredWithoutPhasesInput;
}

export interface PhaseUpdateManyMutationInput {
  title?: String;
  description?: String;
  order?: Int;
}

export interface PlanCreateInput {
  title: String;
  description?: String;
  createdBy: UserCreateOneWithoutPlansInput;
  phases?: PhaseCreateManyWithoutPlanInput;
}

export interface PlanUpdateInput {
  title?: String;
  description?: String;
  createdBy?: UserUpdateOneRequiredWithoutPlansInput;
  phases?: PhaseUpdateManyWithoutPlanInput;
}

export interface PlanUpdateManyMutationInput {
  title?: String;
  description?: String;
}

export interface SessionUpdateInput {
  title?: String;
  purpose?: String;
  day?: Int;
  createdBy?: UserUpdateOneRequiredInput;
  description?: String;
}

export interface SessionUpdateManyMutationInput {
  title?: String;
  purpose?: String;
  day?: Int;
  description?: String;
}

export interface SetUpdateInput {
  title?: String;
  order?: Int;
  bouts?: BoutUpdateManyWithoutSetInput;
  pauses?: PauseUpdateManyWithoutSetInput;
  session?: SessionUpdateOneInput;
}

export interface SetUpdateManyMutationInput {
  title?: String;
  order?: Int;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  plans?: PlanUpdateManyWithoutCreatedByInput;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
}

export interface WeekUpdateInput {
  description?: String;
  order?: Int;
  createdBy?: UserUpdateOneRequiredInput;
  sessions?: SessionUpdateManyInput;
  phase?: PhaseUpdateOneWithoutWeeksInput;
}

export interface WeekUpdateManyMutationInput {
  description?: String;
  order?: Int;
}

export interface AdvancedSessionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AdvancedSessionWhereInput;
  AND?:
    | AdvancedSessionSubscriptionWhereInput[]
    | AdvancedSessionSubscriptionWhereInput;
  OR?:
    | AdvancedSessionSubscriptionWhereInput[]
    | AdvancedSessionSubscriptionWhereInput;
  NOT?:
    | AdvancedSessionSubscriptionWhereInput[]
    | AdvancedSessionSubscriptionWhereInput;
}

export interface BoutSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BoutWhereInput;
  AND?: BoutSubscriptionWhereInput[] | BoutSubscriptionWhereInput;
  OR?: BoutSubscriptionWhereInput[] | BoutSubscriptionWhereInput;
  NOT?: BoutSubscriptionWhereInput[] | BoutSubscriptionWhereInput;
}

export interface IntensitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: IntensityWhereInput;
  AND?: IntensitySubscriptionWhereInput[] | IntensitySubscriptionWhereInput;
  OR?: IntensitySubscriptionWhereInput[] | IntensitySubscriptionWhereInput;
  NOT?: IntensitySubscriptionWhereInput[] | IntensitySubscriptionWhereInput;
}

export interface PauseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PauseWhereInput;
  AND?: PauseSubscriptionWhereInput[] | PauseSubscriptionWhereInput;
  OR?: PauseSubscriptionWhereInput[] | PauseSubscriptionWhereInput;
  NOT?: PauseSubscriptionWhereInput[] | PauseSubscriptionWhereInput;
}

export interface PhaseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PhaseWhereInput;
  AND?: PhaseSubscriptionWhereInput[] | PhaseSubscriptionWhereInput;
  OR?: PhaseSubscriptionWhereInput[] | PhaseSubscriptionWhereInput;
  NOT?: PhaseSubscriptionWhereInput[] | PhaseSubscriptionWhereInput;
}

export interface PlanSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlanWhereInput;
  AND?: PlanSubscriptionWhereInput[] | PlanSubscriptionWhereInput;
  OR?: PlanSubscriptionWhereInput[] | PlanSubscriptionWhereInput;
  NOT?: PlanSubscriptionWhereInput[] | PlanSubscriptionWhereInput;
}

export interface SessionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SessionWhereInput;
  AND?: SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput;
  OR?: SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput;
  NOT?: SessionSubscriptionWhereInput[] | SessionSubscriptionWhereInput;
}

export interface SetSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SetWhereInput;
  AND?: SetSubscriptionWhereInput[] | SetSubscriptionWhereInput;
  OR?: SetSubscriptionWhereInput[] | SetSubscriptionWhereInput;
  NOT?: SetSubscriptionWhereInput[] | SetSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface WeekSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WeekWhereInput;
  AND?: WeekSubscriptionWhereInput[] | WeekSubscriptionWhereInput;
  OR?: WeekSubscriptionWhereInput[] | WeekSubscriptionWhereInput;
  NOT?: WeekSubscriptionWhereInput[] | WeekSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AdvancedSession {
  id: ID_Output;
  title?: String;
  purpose?: String;
  day?: Int;
}

export interface AdvancedSessionPromise
  extends Promise<AdvancedSession>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  purpose: () => Promise<String>;
  day: () => Promise<Int>;
  createdBy: <T = UserPromise>() => T;
  week: <T = FragmentableArray<Week>>(
    args?: {
      where?: WeekWhereInput;
      orderBy?: WeekOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sets: <T = FragmentableArray<Set>>(
    args?: {
      where?: SetWhereInput;
      orderBy?: SetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pauses: <T = FragmentableArray<Pause>>(
    args?: {
      where?: PauseWhereInput;
      orderBy?: PauseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AdvancedSessionSubscription
  extends Promise<AsyncIterator<AdvancedSession>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  purpose: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<Int>>;
  createdBy: <T = UserSubscription>() => T;
  week: <T = Promise<AsyncIterator<WeekSubscription>>>(
    args?: {
      where?: WeekWhereInput;
      orderBy?: WeekOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sets: <T = Promise<AsyncIterator<SetSubscription>>>(
    args?: {
      where?: SetWhereInput;
      orderBy?: SetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pauses: <T = Promise<AsyncIterator<PauseSubscription>>>(
    args?: {
      where?: PauseWhereInput;
      orderBy?: PauseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  plans: <T = FragmentableArray<Plan>>(
    args?: {
      where?: PlanWhereInput;
      orderBy?: PlanOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  plans: <T = Promise<AsyncIterator<PlanSubscription>>>(
    args?: {
      where?: PlanWhereInput;
      orderBy?: PlanOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Plan {
  id: ID_Output;
  title: String;
  description?: String;
}

export interface PlanPromise extends Promise<Plan>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdBy: <T = UserPromise>() => T;
  phases: <T = FragmentableArray<Phase>>(
    args?: {
      where?: PhaseWhereInput;
      orderBy?: PhaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PlanSubscription
  extends Promise<AsyncIterator<Plan>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdBy: <T = UserSubscription>() => T;
  phases: <T = Promise<AsyncIterator<PhaseSubscription>>>(
    args?: {
      where?: PhaseWhereInput;
      orderBy?: PhaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Phase {
  id: ID_Output;
  title: String;
  description?: String;
  order?: Int;
}

export interface PhasePromise extends Promise<Phase>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  order: () => Promise<Int>;
  createdBy: <T = UserPromise>() => T;
  weeks: <T = FragmentableArray<Week>>(
    args?: {
      where?: WeekWhereInput;
      orderBy?: WeekOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  plan: <T = PlanPromise>() => T;
}

export interface PhaseSubscription
  extends Promise<AsyncIterator<Phase>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdBy: <T = UserSubscription>() => T;
  weeks: <T = Promise<AsyncIterator<WeekSubscription>>>(
    args?: {
      where?: WeekWhereInput;
      orderBy?: WeekOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  plan: <T = PlanSubscription>() => T;
}

export interface Week {
  id: ID_Output;
  description?: String;
  order?: Int;
}

export interface WeekPromise extends Promise<Week>, Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  order: () => Promise<Int>;
  createdBy: <T = UserPromise>() => T;
  sessions: <T = FragmentableArray<Session>>(
    args?: {
      where?: SessionWhereInput;
      orderBy?: SessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  phase: <T = PhasePromise>() => T;
}

export interface WeekSubscription
  extends Promise<AsyncIterator<Week>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  createdBy: <T = UserSubscription>() => T;
  sessions: <T = Promise<AsyncIterator<SessionSubscription>>>(
    args?: {
      where?: SessionWhereInput;
      orderBy?: SessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  phase: <T = PhaseSubscription>() => T;
}

export interface Session {
  id: ID_Output;
  title?: String;
  purpose?: String;
  day?: Int;
  description?: String;
}

export interface SessionPromise extends Promise<Session>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  purpose: () => Promise<String>;
  day: () => Promise<Int>;
  createdBy: <T = UserPromise>() => T;
  description: () => Promise<String>;
}

export interface SessionSubscription
  extends Promise<AsyncIterator<Session>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  purpose: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<Int>>;
  createdBy: <T = UserSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
}

export interface Set {
  id: ID_Output;
  title: String;
  order: Int;
}

export interface SetPromise extends Promise<Set>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  order: () => Promise<Int>;
  bouts: <T = FragmentableArray<Bout>>(
    args?: {
      where?: BoutWhereInput;
      orderBy?: BoutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pauses: <T = FragmentableArray<Pause>>(
    args?: {
      where?: PauseWhereInput;
      orderBy?: PauseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  session: <T = SessionPromise>() => T;
}

export interface SetSubscription
  extends Promise<AsyncIterator<Set>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  bouts: <T = Promise<AsyncIterator<BoutSubscription>>>(
    args?: {
      where?: BoutWhereInput;
      orderBy?: BoutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pauses: <T = Promise<AsyncIterator<PauseSubscription>>>(
    args?: {
      where?: PauseWhereInput;
      orderBy?: PauseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  session: <T = SessionSubscription>() => T;
}

export interface Bout {
  duration?: Int;
  length?: Int;
  order: Int;
}

export interface BoutPromise extends Promise<Bout>, Fragmentable {
  intensity: <T = IntensityPromise>() => T;
  duration: () => Promise<Int>;
  length: () => Promise<Int>;
  order: () => Promise<Int>;
  set: <T = SetPromise>() => T;
}

export interface BoutSubscription
  extends Promise<AsyncIterator<Bout>>,
    Fragmentable {
  intensity: <T = IntensitySubscription>() => T;
  duration: () => Promise<AsyncIterator<Int>>;
  length: () => Promise<AsyncIterator<Int>>;
  order: () => Promise<AsyncIterator<Int>>;
  set: <T = SetSubscription>() => T;
}

export interface Intensity {
  id: ID_Output;
  title: String;
  description?: String;
  type?: IntensityType;
  coefficient: Float;
}

export interface IntensityPromise extends Promise<Intensity>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<IntensityType>;
  coefficient: () => Promise<Float>;
}

export interface IntensitySubscription
  extends Promise<AsyncIterator<Intensity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<IntensityType>>;
  coefficient: () => Promise<AsyncIterator<Float>>;
}

export interface Pause {
  id: ID_Output;
  duration?: Int;
  length?: Int;
  order: Int;
  type: PauseType;
}

export interface PausePromise extends Promise<Pause>, Fragmentable {
  id: () => Promise<ID_Output>;
  duration: () => Promise<Int>;
  length: () => Promise<Int>;
  order: () => Promise<Int>;
  type: () => Promise<PauseType>;
  set: <T = SetPromise>() => T;
  session: <T = SessionPromise>() => T;
}

export interface PauseSubscription
  extends Promise<AsyncIterator<Pause>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  duration: () => Promise<AsyncIterator<Int>>;
  length: () => Promise<AsyncIterator<Int>>;
  order: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<PauseType>>;
  set: <T = SetSubscription>() => T;
  session: <T = SessionSubscription>() => T;
}

export interface AdvancedSessionConnection {
  pageInfo: PageInfo;
  edges: AdvancedSessionEdge[];
}

export interface AdvancedSessionConnectionPromise
  extends Promise<AdvancedSessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdvancedSessionEdge>>() => T;
  aggregate: <T = AggregateAdvancedSessionPromise>() => T;
}

export interface AdvancedSessionConnectionSubscription
  extends Promise<AsyncIterator<AdvancedSessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdvancedSessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdvancedSessionSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AdvancedSessionEdge {
  node: AdvancedSession;
  cursor: String;
}

export interface AdvancedSessionEdgePromise
  extends Promise<AdvancedSessionEdge>,
    Fragmentable {
  node: <T = AdvancedSessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdvancedSessionEdgeSubscription
  extends Promise<AsyncIterator<AdvancedSessionEdge>>,
    Fragmentable {
  node: <T = AdvancedSessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAdvancedSession {
  count: Int;
}

export interface AggregateAdvancedSessionPromise
  extends Promise<AggregateAdvancedSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdvancedSessionSubscription
  extends Promise<AsyncIterator<AggregateAdvancedSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BoutConnection {
  pageInfo: PageInfo;
  edges: BoutEdge[];
}

export interface BoutConnectionPromise
  extends Promise<BoutConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BoutEdge>>() => T;
  aggregate: <T = AggregateBoutPromise>() => T;
}

export interface BoutConnectionSubscription
  extends Promise<AsyncIterator<BoutConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BoutEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBoutSubscription>() => T;
}

export interface BoutEdge {
  node: Bout;
  cursor: String;
}

export interface BoutEdgePromise extends Promise<BoutEdge>, Fragmentable {
  node: <T = BoutPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BoutEdgeSubscription
  extends Promise<AsyncIterator<BoutEdge>>,
    Fragmentable {
  node: <T = BoutSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBout {
  count: Int;
}

export interface AggregateBoutPromise
  extends Promise<AggregateBout>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBoutSubscription
  extends Promise<AsyncIterator<AggregateBout>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IntensityConnection {
  pageInfo: PageInfo;
  edges: IntensityEdge[];
}

export interface IntensityConnectionPromise
  extends Promise<IntensityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IntensityEdge>>() => T;
  aggregate: <T = AggregateIntensityPromise>() => T;
}

export interface IntensityConnectionSubscription
  extends Promise<AsyncIterator<IntensityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IntensityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIntensitySubscription>() => T;
}

export interface IntensityEdge {
  node: Intensity;
  cursor: String;
}

export interface IntensityEdgePromise
  extends Promise<IntensityEdge>,
    Fragmentable {
  node: <T = IntensityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IntensityEdgeSubscription
  extends Promise<AsyncIterator<IntensityEdge>>,
    Fragmentable {
  node: <T = IntensitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateIntensity {
  count: Int;
}

export interface AggregateIntensityPromise
  extends Promise<AggregateIntensity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIntensitySubscription
  extends Promise<AsyncIterator<AggregateIntensity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PauseConnection {
  pageInfo: PageInfo;
  edges: PauseEdge[];
}

export interface PauseConnectionPromise
  extends Promise<PauseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PauseEdge>>() => T;
  aggregate: <T = AggregatePausePromise>() => T;
}

export interface PauseConnectionSubscription
  extends Promise<AsyncIterator<PauseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PauseEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePauseSubscription>() => T;
}

export interface PauseEdge {
  node: Pause;
  cursor: String;
}

export interface PauseEdgePromise extends Promise<PauseEdge>, Fragmentable {
  node: <T = PausePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PauseEdgeSubscription
  extends Promise<AsyncIterator<PauseEdge>>,
    Fragmentable {
  node: <T = PauseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePause {
  count: Int;
}

export interface AggregatePausePromise
  extends Promise<AggregatePause>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePauseSubscription
  extends Promise<AsyncIterator<AggregatePause>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PhaseConnection {
  pageInfo: PageInfo;
  edges: PhaseEdge[];
}

export interface PhaseConnectionPromise
  extends Promise<PhaseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhaseEdge>>() => T;
  aggregate: <T = AggregatePhasePromise>() => T;
}

export interface PhaseConnectionSubscription
  extends Promise<AsyncIterator<PhaseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PhaseEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhaseSubscription>() => T;
}

export interface PhaseEdge {
  node: Phase;
  cursor: String;
}

export interface PhaseEdgePromise extends Promise<PhaseEdge>, Fragmentable {
  node: <T = PhasePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhaseEdgeSubscription
  extends Promise<AsyncIterator<PhaseEdge>>,
    Fragmentable {
  node: <T = PhaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePhase {
  count: Int;
}

export interface AggregatePhasePromise
  extends Promise<AggregatePhase>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhaseSubscription
  extends Promise<AsyncIterator<AggregatePhase>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlanConnection {
  pageInfo: PageInfo;
  edges: PlanEdge[];
}

export interface PlanConnectionPromise
  extends Promise<PlanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlanEdge>>() => T;
  aggregate: <T = AggregatePlanPromise>() => T;
}

export interface PlanConnectionSubscription
  extends Promise<AsyncIterator<PlanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlanEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlanSubscription>() => T;
}

export interface PlanEdge {
  node: Plan;
  cursor: String;
}

export interface PlanEdgePromise extends Promise<PlanEdge>, Fragmentable {
  node: <T = PlanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlanEdgeSubscription
  extends Promise<AsyncIterator<PlanEdge>>,
    Fragmentable {
  node: <T = PlanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePlan {
  count: Int;
}

export interface AggregatePlanPromise
  extends Promise<AggregatePlan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlanSubscription
  extends Promise<AsyncIterator<AggregatePlan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SessionConnection {
  pageInfo: PageInfo;
  edges: SessionEdge[];
}

export interface SessionConnectionPromise
  extends Promise<SessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SessionEdge>>() => T;
  aggregate: <T = AggregateSessionPromise>() => T;
}

export interface SessionConnectionSubscription
  extends Promise<AsyncIterator<SessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSessionSubscription>() => T;
}

export interface SessionEdge {
  node: Session;
  cursor: String;
}

export interface SessionEdgePromise extends Promise<SessionEdge>, Fragmentable {
  node: <T = SessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SessionEdgeSubscription
  extends Promise<AsyncIterator<SessionEdge>>,
    Fragmentable {
  node: <T = SessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSession {
  count: Int;
}

export interface AggregateSessionPromise
  extends Promise<AggregateSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSessionSubscription
  extends Promise<AsyncIterator<AggregateSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SetConnection {
  pageInfo: PageInfo;
  edges: SetEdge[];
}

export interface SetConnectionPromise
  extends Promise<SetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SetEdge>>() => T;
  aggregate: <T = AggregateSetPromise>() => T;
}

export interface SetConnectionSubscription
  extends Promise<AsyncIterator<SetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSetSubscription>() => T;
}

export interface SetEdge {
  node: Set;
  cursor: String;
}

export interface SetEdgePromise extends Promise<SetEdge>, Fragmentable {
  node: <T = SetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SetEdgeSubscription
  extends Promise<AsyncIterator<SetEdge>>,
    Fragmentable {
  node: <T = SetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSet {
  count: Int;
}

export interface AggregateSetPromise
  extends Promise<AggregateSet>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSetSubscription
  extends Promise<AsyncIterator<AggregateSet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WeekConnection {
  pageInfo: PageInfo;
  edges: WeekEdge[];
}

export interface WeekConnectionPromise
  extends Promise<WeekConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WeekEdge>>() => T;
  aggregate: <T = AggregateWeekPromise>() => T;
}

export interface WeekConnectionSubscription
  extends Promise<AsyncIterator<WeekConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WeekEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWeekSubscription>() => T;
}

export interface WeekEdge {
  node: Week;
  cursor: String;
}

export interface WeekEdgePromise extends Promise<WeekEdge>, Fragmentable {
  node: <T = WeekPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WeekEdgeSubscription
  extends Promise<AsyncIterator<WeekEdge>>,
    Fragmentable {
  node: <T = WeekSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWeek {
  count: Int;
}

export interface AggregateWeekPromise
  extends Promise<AggregateWeek>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWeekSubscription
  extends Promise<AsyncIterator<AggregateWeek>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AdvancedSessionSubscriptionPayload {
  mutation: MutationType;
  node: AdvancedSession;
  updatedFields: String[];
  previousValues: AdvancedSessionPreviousValues;
}

export interface AdvancedSessionSubscriptionPayloadPromise
  extends Promise<AdvancedSessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdvancedSessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdvancedSessionPreviousValuesPromise>() => T;
}

export interface AdvancedSessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdvancedSessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdvancedSessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdvancedSessionPreviousValuesSubscription>() => T;
}

export interface AdvancedSessionPreviousValues {
  id: ID_Output;
  title?: String;
  purpose?: String;
  day?: Int;
}

export interface AdvancedSessionPreviousValuesPromise
  extends Promise<AdvancedSessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  purpose: () => Promise<String>;
  day: () => Promise<Int>;
}

export interface AdvancedSessionPreviousValuesSubscription
  extends Promise<AsyncIterator<AdvancedSessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  purpose: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<Int>>;
}

export interface BoutSubscriptionPayload {
  mutation: MutationType;
  node: Bout;
  updatedFields: String[];
  previousValues: BoutPreviousValues;
}

export interface BoutSubscriptionPayloadPromise
  extends Promise<BoutSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BoutPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BoutPreviousValuesPromise>() => T;
}

export interface BoutSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BoutSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BoutSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BoutPreviousValuesSubscription>() => T;
}

export interface BoutPreviousValues {
  duration?: Int;
  length?: Int;
  order: Int;
}

export interface BoutPreviousValuesPromise
  extends Promise<BoutPreviousValues>,
    Fragmentable {
  duration: () => Promise<Int>;
  length: () => Promise<Int>;
  order: () => Promise<Int>;
}

export interface BoutPreviousValuesSubscription
  extends Promise<AsyncIterator<BoutPreviousValues>>,
    Fragmentable {
  duration: () => Promise<AsyncIterator<Int>>;
  length: () => Promise<AsyncIterator<Int>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface IntensitySubscriptionPayload {
  mutation: MutationType;
  node: Intensity;
  updatedFields: String[];
  previousValues: IntensityPreviousValues;
}

export interface IntensitySubscriptionPayloadPromise
  extends Promise<IntensitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IntensityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IntensityPreviousValuesPromise>() => T;
}

export interface IntensitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IntensitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IntensitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IntensityPreviousValuesSubscription>() => T;
}

export interface IntensityPreviousValues {
  id: ID_Output;
  title: String;
  description?: String;
  type?: IntensityType;
  coefficient: Float;
}

export interface IntensityPreviousValuesPromise
  extends Promise<IntensityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<IntensityType>;
  coefficient: () => Promise<Float>;
}

export interface IntensityPreviousValuesSubscription
  extends Promise<AsyncIterator<IntensityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<IntensityType>>;
  coefficient: () => Promise<AsyncIterator<Float>>;
}

export interface PauseSubscriptionPayload {
  mutation: MutationType;
  node: Pause;
  updatedFields: String[];
  previousValues: PausePreviousValues;
}

export interface PauseSubscriptionPayloadPromise
  extends Promise<PauseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PausePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PausePreviousValuesPromise>() => T;
}

export interface PauseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PauseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PauseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PausePreviousValuesSubscription>() => T;
}

export interface PausePreviousValues {
  id: ID_Output;
  duration?: Int;
  length?: Int;
  order: Int;
  type: PauseType;
}

export interface PausePreviousValuesPromise
  extends Promise<PausePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  duration: () => Promise<Int>;
  length: () => Promise<Int>;
  order: () => Promise<Int>;
  type: () => Promise<PauseType>;
}

export interface PausePreviousValuesSubscription
  extends Promise<AsyncIterator<PausePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  duration: () => Promise<AsyncIterator<Int>>;
  length: () => Promise<AsyncIterator<Int>>;
  order: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<PauseType>>;
}

export interface PhaseSubscriptionPayload {
  mutation: MutationType;
  node: Phase;
  updatedFields: String[];
  previousValues: PhasePreviousValues;
}

export interface PhaseSubscriptionPayloadPromise
  extends Promise<PhaseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhasePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhasePreviousValuesPromise>() => T;
}

export interface PhaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhaseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhasePreviousValuesSubscription>() => T;
}

export interface PhasePreviousValues {
  id: ID_Output;
  title: String;
  description?: String;
  order?: Int;
}

export interface PhasePreviousValuesPromise
  extends Promise<PhasePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface PhasePreviousValuesSubscription
  extends Promise<AsyncIterator<PhasePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface PlanSubscriptionPayload {
  mutation: MutationType;
  node: Plan;
  updatedFields: String[];
  previousValues: PlanPreviousValues;
}

export interface PlanSubscriptionPayloadPromise
  extends Promise<PlanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlanPreviousValuesPromise>() => T;
}

export interface PlanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlanPreviousValuesSubscription>() => T;
}

export interface PlanPreviousValues {
  id: ID_Output;
  title: String;
  description?: String;
}

export interface PlanPreviousValuesPromise
  extends Promise<PlanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface PlanPreviousValuesSubscription
  extends Promise<AsyncIterator<PlanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface SessionSubscriptionPayload {
  mutation: MutationType;
  node: Session;
  updatedFields: String[];
  previousValues: SessionPreviousValues;
}

export interface SessionSubscriptionPayloadPromise
  extends Promise<SessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SessionPreviousValuesPromise>() => T;
}

export interface SessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SessionPreviousValuesSubscription>() => T;
}

export interface SessionPreviousValues {
  id: ID_Output;
  title?: String;
  purpose?: String;
  day?: Int;
  description?: String;
}

export interface SessionPreviousValuesPromise
  extends Promise<SessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  purpose: () => Promise<String>;
  day: () => Promise<Int>;
  description: () => Promise<String>;
}

export interface SessionPreviousValuesSubscription
  extends Promise<AsyncIterator<SessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  purpose: () => Promise<AsyncIterator<String>>;
  day: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface SetSubscriptionPayload {
  mutation: MutationType;
  node: Set;
  updatedFields: String[];
  previousValues: SetPreviousValues;
}

export interface SetSubscriptionPayloadPromise
  extends Promise<SetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SetPreviousValuesPromise>() => T;
}

export interface SetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SetPreviousValuesSubscription>() => T;
}

export interface SetPreviousValues {
  id: ID_Output;
  title: String;
  order: Int;
}

export interface SetPreviousValuesPromise
  extends Promise<SetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface SetPreviousValuesSubscription
  extends Promise<AsyncIterator<SetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface WeekSubscriptionPayload {
  mutation: MutationType;
  node: Week;
  updatedFields: String[];
  previousValues: WeekPreviousValues;
}

export interface WeekSubscriptionPayloadPromise
  extends Promise<WeekSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WeekPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WeekPreviousValuesPromise>() => T;
}

export interface WeekSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WeekSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WeekSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WeekPreviousValuesSubscription>() => T;
}

export interface WeekPreviousValues {
  id: ID_Output;
  description?: String;
  order?: Int;
}

export interface WeekPreviousValuesPromise
  extends Promise<WeekPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface WeekPreviousValuesSubscription
  extends Promise<AsyncIterator<WeekPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Plan",
    embedded: false
  },
  {
    name: "Phase",
    embedded: false
  },
  {
    name: "Week",
    embedded: false
  },
  {
    name: "Session",
    embedded: false
  },
  {
    name: "AdvancedSession",
    embedded: false
  },
  {
    name: "Set",
    embedded: false
  },
  {
    name: "Pause",
    embedded: false
  },
  {
    name: "PauseType",
    embedded: false
  },
  {
    name: "Intensity",
    embedded: false
  },
  {
    name: "Bout",
    embedded: false
  },
  {
    name: "IntensityType",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
